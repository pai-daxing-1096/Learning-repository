# Shell脚本学习笔记

---

### 1.编写规范

#### (1)脚本后缀名规范

Shell脚本就是一个文本文件，后缀名建议使用`.sh`结尾

#### (2)首行格式规范

首行需要设置Shell解析器的类型，语法：

``````shell
#!/usr/bin/env bash
``````

>含义：设置当前shell脚本文件采用bash解析器运行脚本代码

#### (3)注释格式

单行注释：

``````shell
# 注释内容
``````

多行注释：

``````shell
:<<!
# 注释内容1
# 注释内容2
!
``````

#### (4)单双引号的使用

```
''
```

> 内部所有字符都保持原样**不会进行任何变量替换、命令替换、转义处理**
>
> 即便在命令执行到此行时也不会直接解释里面的内容，而是等后续得到输入时开始解释

```
""
```

> 会进行**变量替换**和**命令替换**，但保留其他字符原样
>
> 在命令执行到此行时会直接解释里面的内容

---

### 2.脚本文件常见的三种解析方式

#### (1) sh解析器执行方式

使用sh命令执行脚本文件，本质是使用Shell解析器运行脚本文件

``````shell
sh 脚本文件
``````

#### (2) bash解析器执行方式

使用bash命令执行脚本文件，本质是使用Shell解析器运行脚本文件

``````shell
bash 脚本文件
``````

#### (3) 仅路径执行方式

执行当前目录下的脚本文件

``````shell
./脚本文件
``````

>脚本文件自己执行需要所需权限，否则无法执行

---

### 3.自定义变量的增删改查

#### (1)自定义变量

语法：

``````shell
变量名="值"
``````

变量定义规则

- 变量名称可以有字母，数字和下划线组成，但是不能以数字开头
- 等号两侧不能有空格
- 在bash环境中，变量的默认类型都是字符串类型，无法直接进行数值运算
- 变量的值如果有空格，必须使用双引号括起来
- 不能使用Shell的关键字作为变量名称

> 局部变量仅在当前 Shell 进程中有效，子 Shell 无法访问，退出脚本后变量失效

#### (2)自定义变量的查询/调用

语法：

``````shell
$变量名
``````

``````shell
${变量名}
``````

>区别：
>
>加`{}`的用法可用于拼接字符串，例如`${name}123`

#### (3)自定义变量的修改

语法：

``````shell
变量名="新值"
``````

> 直接替换即可

#### (4)自定义变量的删除

语法：

``````shell
unset 变量名
``````

---

### 4.自定义常量

介绍：

> 就是变量设置值以后不可以修改的变量叫常量，也叫只读变量

语法：

``````shell
readonly 变量名="值"
``````

注意：

> 只读变量(常量)无法用 `unset` 删除，只能关闭当前 Shell 或重启终端
>
> 除此之外，常量同样分“局部常量”和“全局常量”，和变量相比只是有“只读”区别

---

### 5.变量默认值

**变量默认值语法**是 Shell 中用于处理变量可能未设置或为空时的便捷语法。它可以在变量为空时提供一个备用值，避免脚本因空变量而出错

语法：

``````shell
${变量:-默认值}
``````

- **作用**：如果变量未设置或为空，则返回默认值，但**不改变**原变量

语法：

``````shell
${变量:=默认值}
``````

- **作用**：如果变量未设置或为空，则**设置变量为默认值**并返回

语法：

```shell
${变量:+替代值}
```

- **作用**：如果变量已设置或不为空，则返回替代值

语法：

```shell
${变量:?错误信息}
```

- **作用**：如果变量未设置或为空，输出错误并退出

---

### 6.自定义全局变量\环境变量

```shell
set
```

> 输出全部变量，包括全局变量、局部变量

```shell
env
```

> 显示全部全局变量

```shell
declare
```

> 输出所有变量，如同`set`命令

```shell
export
```

> 显示和设置环境变量值

**父子Shell环境**：

> 如果在A.sh脚本中调用了B.sh脚本，则认为A.sh脚本为B.sh脚本的父Shell环境，B.sh就是子Shell环境

语法：

``````shell
export name="值"
``````

> 全局变量可以在声明处及其子进程中被读取，无法被父进程读取，此外，子进程可以修改全局变量，但是将无法被父进程所读取，只能被其或其子进程读取

#### (1)全局变量(用户级)

```shell
~/.bash_profile
```

> 该文件为Bash登录shell的用户级配置文件，它位于用户主目录下，可使用<u>`export 变量名=值`</u>将变量设置为**环境变量**
>
> 修改 `.bash_profile` 只会影响**当前用户**

```shell
~/.bashrc
```

> `.bashrc` 是 **别名（Aliases）、函数、shell选项和交互式配置** 的主要存放地
>
> 可使用`alias 别名='命令或路径'`设置别名

#### (2)全局变量(系统级)\系统变量

```shell
/etc/profile
```

> 该文件所有用户的Bash登录shell的用户级配置文件，可使用<u>`export 变量名=值`</u>将变量设置为**环境变量**
>
> 修改 `profile` 会影响**所有用户**

``` shell
/etc/profile.d/
```

> 可在此文件下创建自定义配置文件，与上面的方法配置的效果相同**(推荐)**

---

### 7.特殊变量

```shell
$0
```
> 获取Shell脚本名以及脚本路径
```shell
$n
```
> 获取Shell脚本的第n个参数，n在1~9之间，大于9则需要写`${10}$`,参数使用空格隔开
```shell
$#
```
> 获取执行的Shell脚本的参数总个数
```shell
$*
```
> 获取Shell脚本的所有参数，不加引号等同于`$#`，加上引号`“$*”`的作用时接收所有为单个字符串的参数
>
> 即：将所有参数从整体上看作一份数据
```shell
$@
```
> 不加引号效果同`$#`，加引号`$@`则接受所有参数独立的字符串
>
> 即：将每一份参数单独看作一份数据

---

### 8.特殊状态变量

```
$?
```

>取得上一次命令的状态返回值，0为正常执行，1~255则为报错

```
$$
```

>获取当前Shell脚本的进程号

```
$!
```

>获得上一个后台进程的PID

```
$_
```

> 获取上一个被执行命令取得的最后一个参数

---

### 9.Shell子串

#### (1)bash一些基础内置命令

```shell
echo [-n] [-e] [\n] [\r] [\t] [\b]
```

> 可以使用`echo`命令输出指定内容

- `-n`   不换行输出
- `-e`   解析字符串中的特殊符号
- 特殊符号：
	- `\n`   换行
	- `\r`   回车
	- `\t`   制表符(四个空格)
	- `\b`   退一格


```shell
printf "[\n] [\r] [\t] [\b]"
```

> 可以使用`printf`命令输出指定内容,与`echo`命令的区别是使用特殊符号时不需要使用参数`-e`

- `\n`   换行
- `\r`   回车
- `\t`   制表符(四个空格)
- `\b`   退一格

```shell
eval
```

> 将字符串作为命令执行，可同时执行多个命令

### 10.逻辑运算符

```shell
;
```

> 用于连续执行多个命令，按顺序执行，上一个命令**无论是否正确**都会继续执行

```shell
&&
```

> 条件判断中表示：且，用于连续执行多个命令，按顺序执行，上一个命令**成功**才会执行下一个

```shell
||
```

> 条件判断中表示：或，用于连续执行多个命令，按顺序执行，上一个命令**失败**才会执行下一个

```shell
exec
```

> 不创建子进程，执行后续命令，且命令执行完毕后自动执行`exit`命令，常用于执行完命令后退回到上一个用户

---

### 11.运算符

```shell
$((运算式)) 或 $[运算式]
```

> `$((运算式))`支持所有C语言风格的所有算术运算，`$[运算式]`为老写法，现已不建议使用

- `+`  加
- `-`   减
- `*`   乘
- `**`   幂运算
- `>`   小于
- `<`   大于
- `<=`   小于等于
- `>=`   大于等于
- `i++`   自增
- `i--`   自减
- `&`   与
- `|`   或
- `^`   异或
- `&&`   逻辑与
- `||`   逻辑或

```shell
expr [+] [-] [\*] [/] [%]
```

- `+`  加
- `-`   减
- `\*`   乘(此写法为转义符`\`加乘号`*`)
- `/`   除
- `%`   取余

> [!IMPORTANT]
>
> 运算符间需要有空格

---

### 12.条件判断

语法：

```shell
[ 条件1 判断条件 条件2 ]
```

#### (1).常用判断条件：

- `=`   等于，用于**字符串**比较
- `-lt`   小于
- `-le`   小于等于
- `-eq`   等于，用于**数字**比较
- `-gt`   大于
- `-ge`   大于等于
- `-ne`   不等于
- `&&`   且
- `||`   或
- `!`   非

例：

```shell
[ 22 -lt 23 ]
```

> 求22是否小于23，若正确，则可以使用特殊状态变量`$?`查询得到返回值为0，若不正确则返回值为1

例：

```shell 
[ 条件1 ] &&\|| [ 条件2 ]
```

```
[[ 条件1 &&\|| 条件2 ]]
```

> [!IMPORTANT]
>
> 判断条件`&&`和`||`不可以直接使用方括号直接括起来使用

#### (2).按照文件权限进行判断：

- `-r`   阅读权限
- `-w`   写入权限
- `-x`   执行权限

例：

```shell
[ -r /home/pai/text.txt ]
```

> 查询text.txt文件是否有阅读权限，若有权限，则可以使用特殊状态变量`$?`查询得到返回值为0，若无权限则返回值为1

#### (3).按照文件类型进行判断：

- `-f`   文件存在并且是常规文件
- `-e`   文件存在
- `-d`   文件存在并且是目录(文件夹)

例：

```shell
[ -e /home/pai/text.txt ]
```

> 查询text.txt文件是否存在，若存在，则可以使用特殊状态变量`$?`查询得到返回值为0，若不存在则返回值为1

#### (4).[] 的真值表

| 表达式          | 含义           | 返回值（0=真, 1=假） |
| :-------------- | :------------- | :------------------- |
| `[ ]`           | 空表达式       | 1（假）              |
| `[ "" ]`        | 测试空字符串   | 1（假）              |
| `[ "text" ]`    | 测试非空字符串 | 0（真）              |
| `[ -n "text" ]` | 字符串非空     | 0（真）              |
| `[ -z "text" ]` | 字符串为空     | 1（假）              |
| `[ 1 -eq 1 ]`   | 数字相等       | 0（真）              |
| `[ -f file ]`   | 文件存在       | 取决于文件           |

> [!IMPORTANT]
>
> 方括号与条件间同样需要有空格
