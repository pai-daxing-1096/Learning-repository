# Shell脚本学习笔记

---

### 1.编写规范

#### (1)脚本后缀名规范

Shell脚本就是一个文本文件，后缀名建议使用`.sh`结尾

#### (2)首行格式规范

首行需要设置Shell解析器的类型，语法：

``````shell
#!/usr/bin/env bash
``````

>含义：设置当前shell脚本文件采用bash解析器运行脚本代码

#### (3)注释格式

单行注释：

``````shell
# 注释内容
``````

多行注释：

``````shell
:<<!
# 注释内容1
# 注释内容2
!
``````

#### (4)单双引号的使用

```
''
```

> 内部所有字符都保持原样**不会进行任何变量替换、命令替换、转义处理**
>
> 即便在命令执行到此行时也不会直接解释里面的内容，而是等后续得到输入时开始解释

```
""
```

> 会进行**变量替换**和**命令替换**，但保留其他字符原样
>
> 在命令执行到此行时会直接解释里面的内容

---

### 2.脚本文件常见的三种解析方式

#### (1) sh解析器执行方式

使用sh命令执行脚本文件，本质是使用Shell解析器运行脚本文件

``````shell
sh 脚本文件
``````

#### (2) bash解析器执行方式

使用bash命令执行脚本文件，本质是使用Shell解析器运行脚本文件

``````shell
bash 脚本文件
``````

#### (3) 仅路径执行方式

执行当前目录下的脚本文件

``````shell
./脚本文件
``````

>脚本文件自己执行需要所需权限，否则无法执行

---

### 3.自定义变量的增删改查

#### (1)自定义变量

语法：

``````shell
变量名="值"
``````

变量定义规则

- 变量名称可以有字母，数字和下划线组成，但是不能以数字开头
- 等号两侧不能有空格
- 在bash环境中，变量的默认类型都是字符串类型，无法直接进行数值运算
- 变量的值如果有空格，必须使用双引号括起来
- 不能使用Shell的关键字作为变量名称

> 局部变量仅在当前 Shell 进程中有效，子 Shell 无法访问，退出脚本后变量失效

#### (2)自定义变量的查询/调用

语法：

``````shell
$变量名
``````

``````shell
${变量名}
``````

>区别：
>
>加`{}`的用法可用于拼接字符串，例如`${name}123`

#### (3)自定义变量的修改

语法：

``````shell
变量名="新值"
``````

> 直接替换即可

#### (4)自定义变量的删除

语法：

``````shell
unset 变量名
``````

---

### 4.自定义常量

介绍：

> 就是变量设置值以后不可以修改的变量叫常量，也叫只读变量

语法：

``````shell
readonly 变量名="值"
``````

注意：

> 只读变量(常量)无法用 `unset` 删除，只能关闭当前 Shell 或重启终端
>
> 除此之外，常量同样分“局部常量”和“全局常量”，和变量相比只是有“只读”区别

---

### 5.变量默认值

**变量默认值语法**是 Shell 中用于处理变量可能未设置或为空时的便捷语法。它可以在变量为空时提供一个备用值，避免脚本因空变量而出错

语法：

``````shell
${变量:-默认值}
``````

- **作用**：如果变量未设置或为空，则返回默认值，但**不改变**原变量

语法：

``````shell
${变量:=默认值}
``````

- **作用**：如果变量未设置或为空，则**设置变量为默认值**并返回

语法：

```shell
${变量:+替代值}
```

- **作用**：如果变量已设置或不为空，则返回替代值

语法：

```shell
${变量:?错误信息}
```

- **作用**：如果变量未设置或为空，输出错误并退出

---

### 6.自定义全局变量\环境变量

```shell
set
```

> 输出全部变量，包括全局变量、局部变量

```shell
env
```

> 显示全部全局变量

```shell
declare
```

> 输出所有变量，如同`set`命令

```shell
export
```

> 显示和设置环境变量值

**父子Shell环境**：

> 如果在A.sh脚本中调用了B.sh脚本，则认为A.sh脚本为B.sh脚本的父Shell环境，B.sh就是子Shell环境

语法：

``````shell
export name="值"
``````

> 全局变量可以在声明处及其子进程中被读取，无法被父进程读取，此外，子进程可以修改全局变量，但是将无法被父进程所读取，只能被其或其子进程读取

#### (1)全局变量(用户级)

```shell
~/.bash_profile
```

> 该文件为Bash登录shell的用户级配置文件，它位于用户主目录下，可使用<u>`export 变量名=值`</u>将变量设置为**环境变量**
>
> 修改 `.bash_profile` 只会影响**当前用户**

```shell
~/.bashrc
```

> `.bashrc` 是 **别名（Aliases）、函数、shell选项和交互式配置** 的主要存放地
>
> 可使用`alias 别名='命令或路径'`设置别名

#### (2)全局变量(系统级)\系统变量

```shell
/etc/profile
```

> 该文件所有用户的Bash登录shell的用户级配置文件，可使用<u>`export 变量名=值`</u>将变量设置为**环境变量**
>
> 修改 `profile` 会影响**所有用户**

``` shell
/etc/profile.d/
```

> 可在此文件下创建自定义配置文件，与上面的方法配置的效果相同**(推荐)**

---

### 7.特殊变量

```shell
$0
```
> 获取Shell脚本名以及脚本路径
```shell
$n
```
> 获取Shell脚本的第n个参数，n在1~9之间，大于9则需要写`${10}$`,参数使用空格隔开
```shell
$#
```
> 获取执行的Shell脚本的参数总个数
```shell
$*
```
> 获取Shell脚本的所有参数，不加引号等同于`$#`，加上引号`“$*”`的作用时接收所有为单个字符串的参数
>
> 即：将所有参数从整体上看作一份数据
```shell
$@
```
> 不加引号效果同`$#`，加引号`$@`则接受所有参数独立的字符串
>
> 即：将每一份参数单独看作一份数据

---

### 8.特殊状态变量

```
$?
```

>取得上一次命令的状态返回值，0为正常执行，1~255则为报错

```
$$
```

>获取当前Shell脚本的进程号

```
$!
```

>获得上一个后台进程的PID

```
$_
```

> 获取上一个被执行命令取得的最后一个参数
